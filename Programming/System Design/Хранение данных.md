---
создал заметку: 2024-07-31
tags:
  - system-design
---
### Описание

#### Виды баз данных

##### 1. Реляционные базы данных (РБД)

**Описание:** Реляционные базы данных организуют данные в виде таблиц, где каждая строка представляет запись, а столбец — атрибут данных. Основная концепция РБД основана на реляционной модели, предложенной Эдгаром Коддом. Таблицы могут быть связаны между собой с помощью ключей, что позволяет организовывать сложные запросы и поддерживать целостность данных.

**Примеры:** MySQL, PostgreSQL, Oracle, Microsoft SQL Server.

**Преимущества:**
- Поддержка сложных запросов на языке SQL.
- Обеспечение целостности данных благодаря транзакциям и ограничениям.
- Широкая поддержка и зрелое сообщество.

**Недостатки:**
- Могут быть менее эффективны для хранения и обработки нереляционных данных.
- Масштабируемость может быть ограничена, особенно в горизонтальном направлении.
##### 2. Документоориентированные базы данных

**Описание:** Эти базы данных предназначены для хранения, извлечения и управления данными, представленными в формате документов, таких как JSON, XML или BSON. Они не требуют предварительно определенной схемы, что делает их гибкими для работы с динамическими данными.

**Примеры:** MongoDB, CouchDB, Amazon DocumentDB.

**Преимущества:**
- Гибкость в структуре данных.
- Легкость интеграции с современными веб-приложениями, использующими JSON.
- Высокая производительность при работе с вложенными документами.

**Недостатки:**
- Отсутствие поддержки транзакций на уровне SQL (до недавнего времени).
- Возможны проблемы с консистентностью данных.
##### 3. Поисковые движки

**Описание:** Эти системы оптимизированы для выполнения полнотекстового поиска и работы с индексами. Они предназначены для быстрого поиска по большому объему текстовых данных и часто используются для создания поисковых систем на сайтах.

**Примеры:** Elasticsearch, Apache Solr, Amazon CloudSearch.

**Преимущества:**
- Быстрый поиск и индексация.
- Возможность масштабирования для больших объемов данных.
- Поддержка сложных запросов и аналитики.

**Недостатки:**
- Ограниченные возможности для транзакционных операций.
- Необходимость в дополнительной инфраструктуре для индексации данных.
##### 4. Графовые базы данных

**Описание:** Эти базы данных специально разработаны для работы с графами, где данные представлены в виде узлов и ребер. Графовые базы данных идеально подходят для приложений, где важны отношения между объектами, например, социальные сети или системы рекомендаций.

**Примеры:** Neo4j, ArangoDB, Amazon Neptune.

**Преимущества:**
- Эффективная работа с данными, связанными через сложные отношения.
- Высокая производительность для операций поиска и анализа на графах.

**Недостатки:**
- Могут быть сложны в освоении для пользователей без опыта работы с графовыми структурами.
- Ограниченная поддержка стандартных языков запросов, таких как SQL.
##### 5. Key-value хранилища

**Описание:** Эти базы данных хранят данные в виде пар "ключ-значение". Они просты по своей архитектуре и часто используются для кэширования и хранения данных с высокой производительностью.

**Примеры:** Redis, Amazon DynamoDB, Memcached.

**Преимущества:**
- Высокая производительность и масштабируемость.
- Простая модель данных, легкость в использовании.

**Недостатки:**
- Ограниченные возможности для сложных запросов и аналитики.
- Часто используются как дополнение к другим видам баз данных.
##### 6. Колоночные базы данных

**Описание:** Эти базы данных хранят данные в столбцах, а не в строках, что делает их эффективными для выполнения аналитических запросов. Они особенно полезны для работы с большими объемами данных, требующих анализа и отчетности.

**Примеры:** Apache Cassandra, Google Bigtable, HBase.

**Преимущества:**
- Высокая производительность при анализе данных.
- Эффективное сжатие и хранение данных.

**Недостатки:**
- Ограниченная поддержка транзакций и консистентности данных.
- Сложности с обработкой сложных структур данных.
##### 7. Time series базы данных

**Описание:** Эти базы данных оптимизированы для хранения и анализа временных рядов данных, таких как данные с датчиков, финансовые данные или лог-файлы. Они позволяют эффективно управлять и обрабатывать данные, связанные с временными метками.

**Примеры:** InfluxDB, Prometheus, OpenTSDB.

**Преимущества:**
- Оптимизация для работы с временными данными.
- Поддержка агрегатов и временных интервалов.

**Недостатки:**
- Могут быть специализированы на конкретных типах данных.
- Ограниченная поддержка стандартных языков запросов.
##### 8. Blob store

**Описание:** Хранилища BLOB (Binary Large Object) предназначены для хранения больших объёмов бинарных данных, таких как видео, изображения и другие мультимедийные файлы. Они используются, когда необходимо хранить данные больших объёмов, которые не могут быть эффективно сохранены в традиционных реляционных базах данных.

**Примеры:** Amazon S3, Azure Blob Storage, Google Cloud Storage.

**Преимущества:**
- Поддержка больших объемов данных.
- Масштабируемость и доступность.

**Недостатки:**
- Ограниченные возможности для структурированных данных и индексации.
- Необходимость в дополнительных инструментах для управления данными.
#### Классы баз данных

Базы данных можно классифицировать на несколько типов в зависимости от их предназначения, способа хранения данных и архитектурных особенностей.
##### OLAP (Online Analytical Processing)

OLAP базы данных предназначены для выполнения сложных аналитических запросов. Они оптимизированы для чтения больших объемов данных и выполнения сложных агрегаций.

**Примеры использования:** Аналитические системы, бизнес-аналитика, отчетность.
**Характеристики:**
    - Большие объемы данных.
    - Медленные, но сложные запросы.
    - Агрегация и анализ данных.
    - Многомерные модели данных (кубы).
##### OLTP (Online Transaction Processing)

OLTP базы данных оптимизированы для обработки большого количества транзакций с частыми изменениями данных. Они обеспечивают быстрое выполнение операций вставки, обновления и удаления.

**Примеры использования:** Банковские системы, системы бронирования, CRM системы.
**Характеристики:**
    - Высокая частота транзакций.
    - Быстрые и простые запросы.
    - Поддержка ACID свойств для обеспечения целостности данных.
##### HTAP (Hybrid Transactional/Analytical Processing)

HTAP базы данных сочетают в себе свойства OLAP и OLTP систем. Они позволяют выполнять как транзакционные, так и аналитические запросы в рамках одной системы.

**Примеры использования:** Системы, требующие как аналитической, так и транзакционной обработки данных в реальном времени, такие как интернет-магазины с аналитикой пользовательского поведения.

**Характеристики:**
- Гибкость в работе с данными.
- Возможность выполнения транзакционных и аналитических операций одновременно.
- Повышенная производительность за счет оптимизации под оба типа нагрузок.
##### Persistent базы данных

Persistent базы данных хранят данные на *дисках*, обеспечивая долговременное хранение.

**Примеры использования:** Большинство традиционных СУБД, такие как MySQL, PostgreSQL, Oracle.
**Характеристики:**
- Надежное хранение данных.
- Обеспечение целостности и доступности данных.
- Обычно поддерживают ACID свойства.
##### In-memory базы данных

In-memory базы данных хранят данные в *оперативной памяти* для увеличения скорости доступа. Это позволяет значительно ускорить выполнение запросов за счет устранения задержек, связанных с доступом к диску.

**Примеры использования:** Redis, Memcached, SAP HANA.
**Характеристики:**
- Высокая скорость доступа к данным.
- Периодическое сохранение состояния на диск или запись журналов изменений (например, WAL).
- Возможность репликации состояния оперативной памяти на другие машины.
##### Embedded базы данных

Embedded базы данных встроены в приложение и обычно функционируют как *библиотеки, которые работают с файлами*, группируя их и записывая в виде организованных структур.

**Примеры использования:** H2, Berkeley DB.
**Характеристики:**
- Встроенность в приложение, отсутствие необходимости в отдельном сервере.
- Простота развертывания и использования.
- Подходят для мобильных приложений и настольных программ.
##### Single file database

Single file database — это базы данных, где все данные *хранятся в одном файле*. Эти базы данных удобны для простых приложений и ситуаций, где требуется минимальное администрирование.

**Примеры использования:** SQLite.
**Характеристики:**
- Все данные хранятся в одном файле, что упрощает переносимость.
- Ограниченная масштабируемость.
- Простота резервного копирования и восстановления.
#### Выбор БД

Выбор базы данных зависит от множества факторов, которые следует учитывать при проектировании и разработке системы. Основные критерии выбора включают:
1. Транзакции
2. Формат данных
3. Навык работы с технологией
4. Характер обращений к данным
5. Сообщество и зрелось технологии
6. Частота изменяемости формата данных
#### Индексы

Индексы в базах данных — это структуры, которые облегчают и ускоряют поиск данных в таблицах, подобно указателям в книге. Они организуют данные таким образом, чтобы минимизировать количество операций при поиске. Однако создание индексов также увеличивает требования к памяти и замедляет операции записи, поскольку индексы требуют обновления при изменении данных.
##### 1. B-Tree (Балансированные деревья)

**Описание:** B-Tree индексы организованы в виде дерева, где каждый узел содержит ключи и указатели на поддеревья или записи. Эти деревья поддерживаются в сбалансированном состоянии, что обеспечивает равномерное время доступа к данным.

![](https://i.imgur.com/ZvJ0qFF.png)

**Преимущества:**
- Хорошая производительность при чтении и поиске данных.
- Поддержка диапазонных запросов, таких как выборки по интервалу значений.

**Недостатки:**
- Занимает больше места по сравнению с другими типами индексов.
- Увеличивает время вставки, обновления и удаления записей.
##### 2. Hash (Хеш-индексы)

**Описание:** Хеш-индексы используют хеш-функции для преобразования ключей в уникальные индексы, что позволяет быстро находить данные по ключу. Они особенно эффективны для точных соответствий.

![](https://i.imgur.com/qIVc0wT.png)

**Преимущества:**
- Очень быстрое время поиска для точных соответствий.
- Простая структура и использование.

**Недостатки:**
- Не поддерживают диапазонные запросы.
- Возможны коллизии хешей, которые требуют дополнительной обработки.
##### 3. Bitmap (Битовые индексы)

**Описание:** Битовые индексы представляют данные в виде битовых последовательностей, где каждый бит соответствует наличию или отсутствию значения в наборе данных. Они эффективны для работы с данными с небольшим числом уникальных значений.

![](https://i.imgur.com/v4jV5TN.png)

**Преимущества:**
- Эффективно работает с данными, имеющими небольшое количество возможных значений (например, булевы поля).
- Компактное представление данных.

**Недостатки:**
- Неэффективны для полей с большим количеством уникальных значений.
- Могут требовать значительных затрат на обновление.
##### 4. Spatial (Пространственные индексы)

**Описание:** Пространственные индексы предназначены для работы с географическими данными и позволяют выполнять запросы, связанные с пространственными координатами (например, поиск ближайших объектов).

![](https://i.imgur.com/7ZY0uMi.png)

**Преимущества:**
- Оптимизированы для работы с географическими и геометрическими данными.
- Поддержка сложных запросов, таких как ближайшие соседи или пересечения.

**Недостатки:**
- Более сложная реализация и использование.
- Специализированное применение.
##### 5. Reversed (Обратные индексы)

**Описание:** Обратные индексы хранят ассоциации значений с ключами в обратном порядке, что облегчает определенные типы поиска, например, поиск суффиксов в текстовых данных.

![](https://i.imgur.com/lWQWcqi.png)

**Преимущества:**
- Эффективен для поиска по суффиксам или частям значений.
- Поддержка полнотекстового поиска.

**Недостатки:**
- Увеличенное использование памяти.
- Сложная структура и управление.
##### 5. Разряженный индекс

**Описание:** Разряженный индекс (Sparse Index) — характеризуется тем, что каждый ключ ассоциируется с определённым указателем на блок в сортированном файле данных, а не с какой-то определенной записью

**Принцип работы:**
- В отличие от плотных индексов, которые содержат запись для каждого ключа, разряженные индексы используют менее частое покрытие, снижая тем самым объем памяти, необходимый для хранения индекса.
- Каждый вход в разряженный индекс содержит ключевое значение и указатель на блок данных, где можно найти это ключевое значение и последующие ключи.

**Преимущества:**
- **Эффективное использование памяти:** Поскольку индекс содержит меньше записей, он требует меньше места для хранения.
- **Быстрая навигация:** Для больших таблиц разряженные индексы могут быть более эффективны в навигации по таблице, так как они содержат меньше записей для поиска.

**Недостатки:**
- **Ограниченная точность:** Поскольку разряженный индекс не включает каждое ключевое значение, поиск по индексу может быть менее точным и требует дополнительных шагов для нахождения точной записи.
- **Необходимость в дополнительных операциях поиска:** После нахождения блока данных с нужным ключом необходимо выполнить дополнительный поиск по блоку, чтобы найти точную запись.
##### 6. Покрывающие индексы

**Описание:** Покрывающими индексами называются *некластеризованные индексы, которые разрешают один или несколько схожих результатов запроса напрямую, без доступа к базовой таблице и без уточняющих запросов.*

**Преимущества:**
- Снижение времени выполнения запросов за счёт уменьшения количества обращений к диску.
- Ускорение выборок данных, если индекс полностью покрывает запрос.

**Недостатки:**
- Занимают больше места на диске.
- Могут усложнять управление индексами.
##### 7. Кластерные и некластерные индексы

При наличии кластерного индекса строки таблицы упорядочены по значению ключа этого индекса. Если в таблице нет кластерного индекса, таблица называется кучей. Некластерный индекс, созданный для такой таблицы, содержит только указатели на записи таблицы

**Кластерные индексы:**
- Организуют данные таблицы на диске в порядке ключа индекса. Таким образом, сами данные физически упорядочены по значению ключа.
- Преимущества: быстрое чтение данных, упорядоченных по ключу.
- Недостатки: только один кластерный индекс на таблицу, так как упорядочивание по нескольким полям невозможно.

**Некластерные индексы:**
- Хранят только ключи и указатели на записи в таблице. Они не меняют физическое расположение данных.
- Преимущества: могут быть несколько некластерных индексов на таблицу.
- Недостатки: могут потребовать дополнительного времени для доступа к данным, так как требуется дополнительный шаг для обращения к основной таблице.
#### Транзакции

Транзакции — это последовательности операций, которые выполняются как единое целое, обеспечивая целостность и согласованность данных. В случае неудачи одной из операций все изменения, внесенные в рамках транзакции, откатываются, возвращая базу данных в исходное состояние. Это позволяет гарантировать, что данные остаются корректными даже при сбоях системы или ошибках. Основные характеристики транзакций описываются аббревиатурой ACID.
##### ACID-свойства транзакций

Популярные SQL базы данных, появились как раз на почве ACID.
ACID - это стандарт того, какие гарантии должна давать база данных, чтобы поддерживать транзакции (он не указывает деталей реализации)

**Атомарность (Atomicity)**

Атомарность гарантирует, что транзакция выполняется полностью или не выполняется вовсе. Если транзакция не может быть завершена, все изменения откатываются, и база данных возвращается в состояние, существовавшее до начала транзакции. Это достигается с помощью механизмов отката (rollback) и фиксации (commit).

**Согласованность (Consistency)**

Согласованность означает, что данные в базе данных должны удовлетворять всем установленным правилам целостности (например, ограничения целостности). Любая завершенная транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние. Это свойство гарантирует, что после выполнения транзакции все инварианты и ограничения остаются верными.

| Constraint   | Description                         |
| ------------ | ----------------------------------- |
| NOT NULL     | values cannot be null               |
| UNIQUE       | values cannot match any older value |
| PRIMARY KEY  | used to uniquely identify a row     |
| FOREIGN KEY  | references a row in another table   |
| CHECK        | validates condition for new value   |
| DEFAULT      | set default value if not passed     |
| CREATE INDEX | used to speedup the read process    |
*Deferrable transactions:*

Отложенные транзакции (Deferrable Transactions) — это тип транзакций в базах данных, которые позволяют откладывать выполнение проверок целостности до момента фиксации (commit) транзакции. Это означает, что во время выполнения транзакции система может временно позволять изменения, которые нарушают некоторые ограничения целостности, но проверяет их на соответствие всем требованиям только при попытке завершить транзакцию.

![](https://i.imgur.com/Rf5tGTH.png)

**Изоляция (Isolation)**

Изоляция определяет, что действия одной транзакции не видны другим транзакциям до тех пор, пока она не завершится. Это предотвращает проблемы, связанные с параллельным выполнением транзакций, такие как *потерянные обновления, грязное чтение, неповторяющееся чтение, чтение фантомов*.

1. **Потерянное обновление (Lost Update):** Происходит, когда две транзакции одновременно читают данные и обновляют их, но последнее обновление "затирает" изменения, сделанные первой транзакцией.
    
2. **Грязное чтение (Dirty Read):** Транзакция читает данные, измененные другой транзакцией, которая еще не завершена. Если вторая транзакция откатится, первая транзакция окажется в неконсистентном состоянии.
    
3. **Неповторяющееся чтение (Non-repeatable Read):** Происходит, когда транзакция дважды читает одно и то же значение, но получает разные результаты, поскольку между чтениями другая транзакция изменила данные.
    
4. **Чтение фантомов (Phantom Read):** Транзакция видит разное количество строк в таблице при двух одинаковых запросах, потому что другая транзакция добавила или удалила строки.

Существует несколько уровней изоляции, которые позволяют контролировать степень видимости изменений между параллельно выполняющимися транзакциями:

- **Read Uncommitted**: Транзакции могут видеть изменения, внесенные другими транзакциями, до их завершения (грязное чтение, неповторяющиеся чтение, фантомное чтение и потерянное обновление).
- **Read Committed**: Грязное чтение запрещено; транзакция видит только подтвержденные изменения, но могут возникать неповторяющиеся чтение, фантомное чтение и потерянные обновления.
- **Repeatable Read**: Грязные чтения, неповторяющиеся чтения и потерянное обновления предотвращены, но могут возникать фантомные чтения.
- **Serializable**: Максимальный уровень изоляции, при котором транзакции полностью изолированы друг от друга.

*Двухфазная блокировка (Two-Phase Locking, 2PL):*

![](https://i.imgur.com/2p1AH2X.png)

- **Фаза расширения**: запрашиваются все необходимые для определённой транзакции блокировки и никакие блокировки не высвобождаются.
- **Фаза сжатия**: все полученные на фазе роста блокировки высвобождаются.

2PL обеспечивает сериализуемость, но может привести к **взаимоблокировкам**.

*Многоверсионная система управления параллелизмом (MVCC):*

![](https://i.imgur.com/LZwov8c.png)

MVCC позволяет транзакциям работать с "версиями" данных, предоставляя каждому пользователю своё представление данных, что предотвращает конфликты между транзакциями. Это достигается путем хранения нескольких версий данных.

**Устойчивость (Durability)**

Устойчивость гарантирует, что после завершения транзакции её изменения сохранятся в системе даже в случае сбоя (например, потери питания или программного сбоя). Это достигается за счет использования журналов транзакций и механизмов резервного копирования.
##### Журналирование (WAL — Write-Ahead Logging):

Изменения в файлах с данными должны записываться только после того, как эти изменения были занесены в журнал. Записывать страницы данных на диск после подтверждения каждой транзакции нет необходимости, потому что мы знаем, что если случится сбой, то у нас будет возможность восстановить базу данных с помощью журнала.
##### BASE-свойства в NoSQL базах данных

В отличие от ACID, BASE (*Basically Available, Soft State, Eventual Consistency*) — это набор принципов, используемых в NoSQL базах данных, которые предлагают другой подход к управлению данными:

- **Basically Available:** Базы данных будут обеспечивать доступность данных, распространяя и реплицируя их по узлам кластера базы данных.

- **Soft State:** Из-за отсутствия строгой согласованности значения данных могут меняться со временем. Модель BASE разрывается с концепцией базы данных, которая обеспечивает собственную согласованность, делегируя эту ответственность разработчикам.

- **Eventual Consistency:** Вы в конце концов увидите действительные данные, но есть вероятность, что ваша транзакция прочитает недействительные значения - то есть, временные, или частично обновлённые, или устаревшие. Возможно, данные станут согласованными в «ленивом» режиме при чтении.

#### Объекты баз данных

##### Хранимые процедуры (Stored Procedures)

![](https://i.imgur.com/Kgjrs5b.png)
![](https://i.imgur.com/KybyDYh.png)

Хранимые процедуры — это заранее определенные наборы SQL-команд, которые выполняются как единая операция. Они могут принимать входные параметры и возвращать результаты. Хранимые процедуры используются для выполнения повторяющихся задач и бизнес-логики на стороне базы данных.
##### Триггеры (Triggers)

![](https://i.imgur.com/DtM2g6M.png)
![](https://i.imgur.com/Zd22qn7.png)

Триггеры — это специальные объекты баз данных, которые автоматически выполняются при наступлении определенных событий (например, вставка, обновление, удаление записей в таблице). Триггеры используются для обеспечения целостности данных, ведения логов изменений и реализации бизнес-логики.
##### Материализованные представления (Materialized Views)

![](https://i.imgur.com/1rOvK1C.png)
![](https://i.imgur.com/CLu07Rs.png)

В отличие от обычных представлений, материализованные представления хранят результаты запроса на диск. Это позволяет ускорить доступ к данным, так как нет необходимости выполнять сложные запросы при каждом обращении.

**Примеры:** Материализованное представление для предвычисленных агрегатов по продажам.
#### Watch API

Watch API — это механизм, предоставляемый некоторыми базами данных и системами, который позволяет следить за изменениями данных в реальном времени. Watch API используется для уведомления клиентов или других систем об изменениях, таких как создание, обновление или удаление данных. Это может быть полезно для синхронизации данных между системами, реактивного программирования и поддержания актуальности кэша или пользовательских интерфейсов.

**Применение:**
1. **Реактивные приложения:** В приложениях, где пользовательский интерфейс должен обновляться в реальном времени в ответ на изменения данных, Watch API позволяет получать уведомления о таких изменениях, чтобы сразу обновить интерфейс.
    
2. **Синхронизация данных:** Watch API используется для синхронизации данных между несколькими копиями базы данных или между различными системами, обеспечивая консистентность данных.
    
3. **Управление кэшем:** При использовании кэширования данных на стороне клиента или в промежуточных слоях системы, Watch API может уведомлять о необходимости обновления кэша при изменении данных в основной базе.
    
4. **Аналитика и мониторинг:** Для систем, которые отслеживают изменения данных для аналитики или мониторинга (например, отслеживание изменений в учетных записях пользователей), Watch API обеспечивает своевременное уведомление о произошедших событиях.

**Основные функции и возможности:**
1. **Подписка на события:** Клиенты могут подписаться на определенные события, такие как создание, обновление или удаление записей в базе данных. В зависимости от реализации, подписка может быть настроена на определенные таблицы, строки или атрибуты.
    
2. **Получение уведомлений:** Когда событие происходит, клиенты, подписанные на это событие, получают уведомление. Уведомление может включать в себя информацию о типе события, данных, которые были изменены, и другие детали.
    
3. **Фильтрация и настройка:** Некоторые реализации Watch API позволяют фильтровать уведомления по определенным критериям, чтобы получать только необходимые изменения.

**Примеры реализаций:**
1. **Firebase Realtime Database:** Предоставляет механизм для наблюдения за изменениями в данных в режиме реального времени, позволяя приложениям обновлять пользовательский интерфейс мгновенно при изменении данных.
    
2. **MongoDB Change Streams:** Позволяет приложениям получать уведомления о изменениях данных в коллекциях MongoDB в реальном времени.
    
3. **ETCD Watch API:** ETCD, система для хранения ключ-значение, предоставляет API для отслеживания изменений ключей и значений.
#### Брокеры сообщений

![](https://i.imgur.com/3CFI51H.png)

Брокеры сообщений — это промежуточные программные компоненты, которые позволяют передавать сообщения между различными приложениями или компонентами системы, обеспечивая асинхронную коммуникацию, масштабируемость и отказоустойчивость. Брокеры сообщений играют ключевую роль в современных распределенных системах и микросервисных архитектурах, где требуется надежный обмен данными между компонентами, которые могут быть написаны на разных языках программирования или работать на разных платформах.
##### Основные функции брокеров сообщений

1. **Буферизация:** Брокеры сообщений могут буферизировать сообщения, чтобы обеспечить асинхронное взаимодействие между отправителем (производителем) и получателем (потребителем). Это полезно, когда производители генерируют сообщения быстрее, чем потребители могут их обработать.
    
2. **Асинхронная связь:** Брокеры позволяют производителям отправлять сообщения, не дожидаясь, пока получатели их прочитают, и наоборот. Это улучшает производительность и позволяет системе оставаться отзывчивой.
    
3. **Слабое связывание:** Компоненты системы могут быть слабо связаны друг с другом, что означает, что они могут взаимодействовать через брокера сообщений, не зная друг о друге. Это упрощает разработку и поддержание системы, так как компоненты могут изменяться или обновляться независимо.
    
4. **Масштабируемость:** Брокеры сообщений позволяют масштабировать систему, распределяя нагрузку на несколько потребителей и поддерживая балансировку нагрузки.
    
5. **Отказоустойчивость:** Современные брокеры сообщений обеспечивают механизмы для восстановления после сбоев, такие как сохранение сообщений в журнале (логирование), репликация и поддержка различных стратегий доставки (например, "по крайней мере один раз", "не более одного раза").
##### Архитектуры и модели

1. **Очереди (Queues):** В модели очередей сообщения хранятся в очереди, и каждый потребитель получает уникальное сообщение. Как только сообщение прочитано, оно удаляется из очереди. Очереди полезны, когда нужно распределить задачи между несколькими рабочими.
    
2. **Топики и подписки (Topics and Subscriptions):** В этой модели производители публикуют сообщения в топики, а потребители подписываются на эти топики. Все подписчики получают каждое сообщение, отправленное в топик. Это полезно для распространения сообщений многим получателям.
    
3. **Push/Pull модели:** В push-модели брокер активно передает сообщения потребителям, как только они становятся доступны. В pull-модели потребители сами запрашивают сообщения у брокера.
##### Основные компоненты

1. **Producer (Производитель):** Компонент, который отправляет сообщения в брокер сообщений.
    
2. **Consumer (Потребитель):** Компонент, который получает и обрабатывает сообщения от брокера.
    
3. **Broker (Брокер):** Центральный компонент, который принимает сообщения от производителей, сохраняет их и распределяет потребителям.

##### Примеры брокеров сообщений

1. **Apache Kafka:**
    
    - **Особенности:** Высокопроизводительная платформа для обработки потоков данных. Поддерживает устойчивое хранение сообщений и возможность воспроизведения потока.
    - **Использование:** Аналитика данных, мониторинг, логирование, обработка событий.

![](https://i.imgur.com/m9FFG5F.png)

2. **RabbitMQ:**
    
    - **Особенности:** Поддерживает различные протоколы обмена сообщениями, включая AMQP, MQTT и другие. Обеспечивает надежную доставку сообщений и различные модели очередей.
    - **Использование:** Веб-приложения, системы мониторинга, распределенные системы.
    
3. **ActiveMQ:**
    
    - **Особенности:** Поддерживает множество протоколов обмена сообщениями и моделей очередей и топиков. Включает функции устойчивости и масштабируемости.
    - **Использование:** Интеграционные решения, микросервисные архитектуры.
    
4. **AWS SQS (Simple Queue Service):**
    
    - **Особенности:** Облачный сервис очередей сообщений, управляемый AWS. Обеспечивает высокую доступность и масштабируемость.
    - **Использование:** Веб-приложения, системы электронной коммерции, обработка событий.
#### Data retention

Хранение данных определяет политики управления постоянными данными и записями для соблюдения юридических и бизнес-требований к архивированию данных.
#### Гарантии доставки сообщений

1. **At least once (По крайней мере один раз):** Сообщение доставляется как минимум один раз, что означает, что может быть несколько доставок одного и того же сообщения. Эта гарантия требует идемпотентности операций на стороне потребителей.
    
2. **At most once (Не более одного раза):** Сообщение доставляется не более одного раза, что означает, что оно может быть потеряно, но дубликаты исключены.
    
3. **Exactly once (Ровно один раз):** Сообщение доставляется ровно один раз. Это самая строгая и сложная гарантия, требующая специальной обработки на уровне брокера и потребителей.

Брокеры сообщений являются критически важными компонентами в построении масштабируемых и отказоустойчивых систем, обеспечивая надежную и эффективную передачу данных между различными частями системы.
#### Альтернативные способы хранения данных

##### Хранение на клиенте

![](https://i.imgur.com/ARaH7GK.png)
##### CDN

- ﻿﻿Исходный (origin), на котором размещен запрашиваемый сайт, а также связанный с ним визуальный, музыкальный, видеоконтент
- ﻿﻿PoP (point of presence) - точка присутствия вспомогательных серверов. Их сеть размещается в различных регионах
- ﻿﻿Proxy-сервер - это промежуточное звено между пользователем и исходным сервером. Он отвечает за перенаправление, оптимизацию и преобразование передаваемого трафика.

![](https://i.imgur.com/bfDJ1uU.png)

### Краткое содержание
