---
создал заметку: 2024-07-30
tags:
  - golang
  - internal
  - scheduler
---
### Описание

**Планировщик Go** — это компонент, который распределяет задачи между потоками. В контексте языка Go планировщик управляет выполнением [Goroutine](../Concurrency/Goroutine.md) — легковесных потоков, созданных на уровне приложения. Планировщик Go разработан для эффективного использования ресурсов, таких как процессорное время и память, что особенно важно при разработке веб-сервисов с большой нагрузкой ввода-вывода (I/O-bound).
#### Проблемы использования потоков ОС

Использование потоков операционной системы для каждой задачи может быть неэффективным из-за высоких затрат на память и переключений контекстов (context switching). *В среднем, каждый поток ОС занимает до 8 МБ памяти*, что становится дорого при большом количестве потоков. Кроме того, переключение контекстов на уровне ядра ОС требует дополнительных ресурсов и времени.

> [!NOTE]
> Стек потока = в среднем 8 МБ
> Стек горутины = от 2 КБ

10 000 одновременных соединений:
- 80 ГБ RAM при использовании потоков
- 20 МБ RAM при использовании горутин
#### GMP-модель

![](https://i.imgur.com/V1g8j8U.png)

Планировщик Go использует **GMP-модель**:

- **G ([Goroutine](../Concurrency/Goroutine.md))** — легковесный поток, который исполняет код (что исполняем).
- **M (Machine Thread)** — поток ОС, на котором выполняются горутины (где исполняем).
- **P (Processor)** — абстракция для управления ресурсами, такими как очередь горутин (права и ресурсы для исполнения). Количество P можно настроить с помощью функции `runtime.GOMAXPROCS()`.
#### Local Runnable Queue (LRQ)

**LRQ** - Локальная `lock-free FIFO+[1]LIFO` очередь `runnable` горутин, привязанная к определенному процессору (`P`). Очередь реализована в виде *массива указателей на `G` размером 256 элементов*.

```go
type p struct {
	runq [256]guintptr
	runnext guintptr // Тот самый [1]LIFO
}
```
#### Global Runnable Queue (GRQ)

**GRQ** - глобальная FIFO очередь `runnable` горутин. Реализована в виде *двусвязного списка* хранящего горутины, которые не могут быть немедленно выполнены потоками из-за отсутствия доступных ресурсов. Обращение к данной очереди происходит через mutex.

```go
type schedt struct {
	// Global runnable queue.  
	runq     gQueue
}

type gQueue struct {  
    head guintptr  
    tail guintptr  
}
```
#### netpoller

**netpoller** — это компонент в планировщике Go, который отвечает за управление асинхронными I/O операциями, такими как работа с сетевыми соединениями. Он играет ключевую роль в обработке сетевых событий и других операций ввода-вывода, которые могут блокировать выполнение горутин. `netpoller` помогает эффективно обрабатывать множество соединений с использованием ограниченного количества системных потоков.

![](https://i.imgur.com/Fc7PlSC.png)

**Основные функции netpoller:**
1. Асинхронное управление вводом-выводом:
	- `netpoller` используется для мониторинга файловых дескрипторов и других источников ввода-вывода. Он определяет, когда данные готовы для чтения или записи, и уведомляет соответствующие горутины, что позволяет им продолжить выполнение.
	
	- В отличие от синхронных вызовов, которые могут блокировать поток до завершения операции, `netpoller` позволяет продолжить выполнение других задач, пока операция ввода-вывода не будет готова.
	
2. Использование системных вызовов `epoll/kqueue/IOCP`:
	- В зависимости от операционной системы, `netpoller` использует соответствующие механизмы, такие как `epoll` на Linux, `kqueue` на macOS и BSD-системах, или `IOCP` на Windows. Эти механизмы позволяют эффективно отслеживать состояния множества файловых дескрипторов.
	
	- Они уведомляют netpoller, когда файл или сокет готовы к операции, что минимизирует количество блокирующих вызовов и позволяет обрабатывать множество соединений одновременно.
	
3. Уведомление горутин о готовности данных:
	- Когда `netpoller` получает уведомление о том, что дескриптор готов, он вызывает соответствующие горутины для обработки события. Это может быть чтение данных из сети, запись данных в сокет или выполнение других операций ввода-вывода.
	
	- Горутины добавляются в локальные очереди процессоров или в глобальную очередь для выполнения, что позволяет им продолжить работу как можно скорее (возврат также как и при `handoff`).
	
4. Поддержка больших масштабов:

	- `netpoller` позволяет эффективно управлять тысячами и миллионами соединений, что важно для высокопроизводительных сетевых серверов и приложений. Благодаря использованию асинхронного ввода-вывода и событийной модели, Go может обрабатывать большое количество параллельных соединений без необходимости выделения отдельного потока на каждое соединение.
#### Work Stealing

**Механизм "украсть работу" (work-stealing)** — это метод балансировки нагрузки в параллельных системах, который используется для равномерного распределения задач между рабочими потоками (threads).

Когда поток (`M`), связанный с процессором (`P`), исчерпывает задачи в своей локальной очереди, он может попытаться "украсть" работу из локальной очереди другого процессора `P`. Это позволяет загруженным процессорам разгружать свою работу, передавая задачи менее загруженным процессорам.

- У кого забирать выбирается рандомно
- Забирать будет половину горутин

![](https://i.imgur.com/VyN7ZIx.png)

**Алгоритм кражи:**
```go
runtime.schedule() {
// только в 1/61 такт проверяем глобальную очередь на наличие G.
	// если не найдено, проверяем локальную очередь
	// если не найдено, то:
		// попытаться украсть у других P 4 раза
		// если не вышло, проверить глобальную очередь
		// если все равно не вышло, поллить (poll) сеть
}
```
#### Handoff

**Handoff** — это процесс передачи управления или выполнения горутины от одного системного потока (`M`) к другому или от одного процессора (`P`) к другому.

Если горутина выполняет `syscall`, тогда поток (`M`) заблокируется, что приведет к тому, что другие горутины в локальной очереди выполнения будут голодать:

![](https://i.imgur.com/EnMKcEM.png)

Когда это произойдет, планировщик Go вызовет `releasep`, чтобы освободить процессор (`p`). Это приведет к отсоединению `P` от `M`. Затем процессору будет назначен новый поток ядра (`M`), который будет браться из `thread pool` или создастся новый, если пул пустой.

![](https://i.imgur.com/zPMqftP.png)

Передача может быть дорогостоящей, особенно когда нам приходится создавать новый поток ядра для связи с процессором. Кроме того, выполнять передачу для каждого системного вызова не оптимально, поскольку некоторые системные вызовы могут быть кратковременными и поток ядра может быть заблокирован не надолго. Чтобы оптимизировать это сделали следующее:

> [!NOTE]
> Планировщик Go сразу открепит поток (`M`) от процессора (`P`), если понимает, что поток будет заблокирован на системном вызове (`syscall`) в течении долгого времени
> В других случаях (`short-lived syscalls`) он позволит потоку быть заблокированным и не будет откреплять от процессора (`P`)

Также он установит статус, чтобы отразить, что он находится в системном вызове. Используя `sysmon`, планировщик go будет периодически проверять, заблокирован ли еще поток. Если он все еще находится в системном вызове, спустя определенное количество времени, тогда планировщик вытеснит данный поток с выполнения, то есть выполнит *handoff*.
#### Системный вызов завершился

Когда системный вызов завершился, планировщик проверяет, доступен ли старый процессор (тот, который был передан). Если он доступен, то горутина будет связана с ним. Если старый процессор недоступен (`LRQ` полная или `P` на `syscall`), горутина будет связана с любым незанятым процессором. А если свободных процессоров нет, то горутина будет добавлена в глобальную очередь выполнения.

Разблокированный поток отправится в `thread pool` для последующего его переиспользования.
#### sysmon

**sysmon** — это системный монитор, встроенный в рантайм Go, который выполняет различные задачи мониторинга и обслуживания в фоне для поддержания нормальной работы системы.

**Основные функции Sysmon:**

1. **Обнаружение мертвых блокировок (deadlock detection):**
    
    - Sysmon отслеживает горутины, которые могут блокировать выполнение программы. Он периодически проверяет, есть ли активные горутины, и если все горутины заблокированы или программа находится в состоянии простоя длительное время, Sysmon может завершить программу с ошибкой "deadlock detected".
    
2. **Управление таймерами и таймаутами:**
    
    - Sysmon обрабатывает и управляет системными таймерами, такими как таймауты в сетевых операциях или задержки в выполнении горутин. Он следит за временем выполнения задач и может пробуждать горутины, когда истекает таймер.
    
3. **Поддержка garbage collector (GC):**
    
    - Sysmon помогает в работе сборщика мусора, запуская его по мере необходимости. Он может запускать GC при достижении определенного уровня использования памяти или через определенные промежутки времени, чтобы освободить память и предотвратить утечки.
    
4. **Управление прерываниями и сигналами:**
    
    - Sysmon обрабатывает системные сигналы и прерывания, которые могут быть использованы для управления выполнением программы. Например, он может обрабатывать сигналы для завершения программы или для других действий, таких как создание дампов памяти.
    
5. **Управление системными ресурсами:**
    
    - Он также может выполнять другие задачи, связанные с управлением ресурсами системы, такие как управление файлами, сетью или взаимодействие с операционной системой.
### Краткое содержание

**Планировщик Go** — это компонент, который распределяет задачи между потоками. В контексте языка Go планировщик управляет выполнением [Goroutine](../Concurrency/Goroutine.md) — легковесных потоков, созданных на уровне приложения. Планировщик Go разработан для эффективного использования ресурсов, таких как процессорное время и память, что особенно важно при разработке веб-сервисов с большой нагрузкой ввода-вывода (I/O-bound). ^sum-scheduler
