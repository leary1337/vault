---
создал заметку: 2024-08-07 00:01
tags:
  - golang
  - internal
---
### Описание

**Сборщик мусора (Garbage Collector, GC)** в Go — это важный компонент, который управляет автоматическим освобождением памяти, занимаемой объектами, которые больше не используются в программе. Используется алгоритм Tricolor Mark and Sweep, который разработан для конкурентной и эффективной сборки мусора. Этот алгоритм классифицирует объекты на три группы (белые, серые и черные) для определения их доступности и возможности их удаления.

![](https://i.imgur.com/VnGpGmI.gif)
#### Three-color Marker Algorithm

Изначально все объекты в куче и на стеке окрашены в белый.

Все объекты в стадии разметки красятся в чёрный, серый или белый цвет:
- **белый** — потенциальный мусор, ещё не затронутые алгоритмом объекты;
- **серый** — объекты «на рассмотрении»;
- **чёрный** — активные объекты.

*В целом, алгоритм можно представить циклом из нескольких шагов:*
1. Покрасить все корневые объекты (стек и глобальные переменные) в серый.
    
2. Выбрать серый объект из набора серых объектов и пометить его как чёрный.
    
3. Все объекты, на которые указывает чёрный объект, пометить серым. Это гарантирует, что сам объект и объекты, на которые он ссылается, не будут выброшены в мусор.
    
4. Если в графе остались серые объекты, вернуться к шагу 2.

![](https://i.imgur.com/fTn5XCj.gif)
#### Write Barrier

**Write Barrier** — это фрагмент кода, который выполняется при работе с памятью. Он нужен для поддержки инвариантов, которые гарантируют правильное пошаговое выполнение алгоритма.

Write Barrier гарантирует выполнение условий:

- чёрные объекты не указывают на белые объекты, только на серые или другие черные объекты (*dijkstra write barrier*);
    
- любой белый объект, на который указывает черный объект, должен иметь достижимый путь до серого объекта (*yuasa write barrier*)
#### Стадии работы GC

Текущая стадия работы сборщика мусора хранится в глобальной переменной `gcphase`.

**1. Sweep Termination.** *Stop The World (STW)*. Это нужно, чтобы все процессоры дошли до точки, когда можно безопасно запустить GC. После этого все блоки памяти, отмеченные как мусор, отправляются «на съедение» Scavenger. Потом он вернёт их ОС. Это позволяет не запрашивать у ОС больше памяти, чем требуется приложению. В обычных обстоятельствах к началу работы GC вся «мусорная» память уже возвращена системе. Необычным обстоятельством может считаться ручной запуск GC.

**2. Mark.** Глобальная переменная `gcphase` выставляется в значение `_GCmark`. *Включается Write Barrier*. Создаются и ставятся в очередь джобы с покраской корневых вершин. *Корневые вершины — это глобальные переменные и всё содержимое стека.*

Запускаем мир. Теперь маркировка объектов происходит в специальных воркерах-малярах, запущенных шедулером. Эти воркеры проходятся по всем объектам в куче и на стеке. Новые аллоцированные объекты **сразу красятся в чёрный**. Чтобы просканировать стек горутины, её останавливают, прокрашивают стек и снова запускают.

Так продолжается до тех пор, пока не закончатся серые объекты. В этой фазе GC *забирает до 25% от CPU*, это число зашито внутри [Runtime Go](Runtime.md).

**Mark Termination.** *Stop The World*, выставляем `gcphase` на `_GCmarktermination`, выключаем воркеров, которые красили объекты в памяти. `runtime` готовит будущую работу программы. Например, чистит кеш у M.

**Sweep.** Выставляем gcphase на `_GCoff`, *выключается Write Barrier.* Запускаем мир. Теперь новые аллоцированные объекты будут покрашены в белый. Аллокация может происходить поверх блоков памяти, отмеченных как мусор. Кроме того, будет запущена горутина, которая будет постепенно возвращать мусорную память ОС.
#### Когда запускается GC

Есть 3 причины:

1. Превышение динамического лимита «сожранной» приложением памяти, установленного с помощью переменной `GOGC`.
    
2. Прошло 2 минуты без GC. Да, даже если вы ничего не аллоцировали за это время, GC все равно запустится раз в 2 минуты. За это ответственен [Sysmon](Runtime.md). Этот способ можно отключить, выставив значение GOGC < 0. 
    
3. Ручной запуск с помощью `runtime.GC()`. Если сделать этот вызов, когда Garbage Collector уже запущен, то по достижении фазы Sweep он запустится заново.
#### Конфигурация GC

В Go можно настроить сборщик мусора (GC) с помощью нескольких параметров, предоставляемых через среду выполнения.
##### GOGC

Переменная окружения `GOGC` позволяет управлять порогом запуска сборщика мусора. Она задает процент прироста объема используемой памяти, после которого будет запущен сборщик мусора.

**Значение по умолчанию:** 100 (сборка мусора происходит, когда объем используемой памяти удваивается)

```go
package main

import ( "runtime/debug" )

func main() {
	debug.SetGCPercent(200) // Запускать GC, когда объем используемой памяти вырастет на 200%
}
```
##### GOMEMLIMIT

Переменная окружения `GOMEMLIMIT` в Go позволяет ограничить использование памяти программой. Это ограничение влияет на поведение GC, заставляя его чаще запускаться, если объем используемой памяти приближается к заданному лимиту. Эта функция полезна для предотвращения чрезмерного использования памяти и для обеспечения более предсказуемого поведения приложения в условиях ограниченных ресурсов.

`GOMEMLIMIT` задается в байтах, мегабайтах или гигабайтах.

Например, `GOMEMLIMIT=500MB` устанавливает лимит использования памяти на 500 мегабайт.

```go
package main

import (
    "runtime/debug"
)

func main() {
    debug.SetMemoryLimit(500 * 1024 * 1024)  // Устанавливает лимит памяти на 500 мегабайт
}
```
### Краткое содержание

**Сборщик мусора (Garbage Collector, GC)** в Go — это важный компонент, который управляет автоматическим освобождением памяти, занимаемой объектами, которые больше не используются в программе. Используется алгоритм Tricolor Mark and Sweep, который разработан для конкурентной и эффективной сборки мусора. Этот алгоритм классифицирует объекты на три группы (белые, серые и черные) для определения их доступности и возможности их удаления. ^sum-gc
