---
создал заметку: 2024-07-27
tags:
  - golang
  - concurrency
  - pattern
---
### Описание

#### Пул потоков (Thread Pool) или Worker Pool

**Thread Pool** — это паттерн, который предусматривает создание фиксированного количества потоков (горутины в случае Go) для выполнения задач. Задачи поступают в очередь, откуда их берут потоки и выполняют. Этот паттерн помогает ограничить количество одновременно выполняющихся задач, что особенно полезно для управления ресурсами.

**Применение**:

- Управление ограниченными ресурсами (например, подключения к базе данных).
- Выполнение большого числа небольших задач.

**Пример**:

```go
func worker(tasks <-chan int, results chan<- int) {
    for task := range tasks {
        results <- task * 2
    }
}

func main() {
    tasks := make(chan int, 100)
    results := make(chan int, 100)

    for i := 0; i < 3; i++ {
        go worker(tasks, results)
    }

    for i := 1; i <= 5; i++ {
        tasks <- i
    }
    close(tasks)

    for i := 1; i <= 5; i++ {
        fmt.Println(<-results)
    }
}
```
#### Семафор (Semaphore)

**Семафор** — ограничивает количество горутин, которые могут одновременно получить доступ к ресурсу. Например, если у нас есть ресурс, доступный максимум для *n* горутин, то семафор гарантирует, что больше *n* горутин не смогут использовать его одновременно.

**Применение:**

- Ограничение числа одновременно активных горутин.
- Контроль доступа к ограниченным ресурсам.

**Пример:**

```go
type Semaphore struct {
    ch chan struct{}
}

func NewSemaphore(n int) *Semaphore {
    return &Semaphore{
        ch: make(chan struct{}, n),
    }
}

func (s *Semaphore) Acquire() {
    s.ch <- struct{}{}
}

func (s *Semaphore) Release() {
    <-s.ch
}

func worker(id int, sem *Semaphore, wg *sync.WaitGroup) {
    defer wg.Done()
    sem.Acquire()
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(1 * time.Second) // симуляция работы
    fmt.Printf("Worker %d done\n", id)
    sem.Release()
}

func main() {
    sem := NewSemaphore(3)
    var wg sync.WaitGroup

    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, sem, &wg)
    }

    wg.Wait()
}
```
#### Fan-In и Fan-Out

**Fan-In** - несколько источников данных объединяются в один канал, чтобы единая горутина могла обрабатывать все данные.

**Fan-Out** - данные из одного канала распределяются на несколько горутин, каждая из которых обрабатывает часть данных параллельно.

**Применение:**

- Fan-In: Обработка результатов от нескольких горутин в одном месте.
- Fan-Out: Параллельная обработка больших объемов данных для ускорения выполнения.

**Пример Fan-Out:**

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        results <- job * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)

    for a := 1; a <= 5; a++ {
        fmt.Println(<-results)
    }
}
```

**Пример Fan-In:**

```go
// Функция, которая объединяет данные из нескольких каналов в один
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    output := func(c <-chan int) {
        for n := range c {
            out <- n
        }
        wg.Done()
    }

    wg.Add(len(channels))
    for _, c := range channels {
        go output(c)
    }

    // Закрываем выходной канал после завершения всех горутин
    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}

func producer(id int) <-chan int {
    out := make(chan int)
    go func() {
        for i := 0; i < 5; i++ {
            out <- id*10 + i
        }
        close(out)
    }()
    return out
}

func main() {
    ch1 := producer(1)
    ch2 := producer(2)
    ch3 := producer(3)

    out := fanIn(ch1, ch2, ch3)

    for v := range out {
        fmt.Println(v)
    }
}
```
#### Канал передачи сигналов завершения (Done Channel)

Паттерн, в котором используется канал для передачи сигнала завершения. Этот канал используется для уведомления горутин о необходимости завершить свою работу. Это позволяет безопасно завершать горутины, особенно если они заблокированы в ожидании данных или выполняют длительные операции.

**Применение:**

- Управление завершением долгоживущих горутин.
- Аварийное завершение горутин в случае ошибок.

**Пример:**

```go
func worker(done <-chan struct{}) {
    for {
        select {
        case <-done:
            fmt.Println("Worker exiting")
            return
        default:
            // Do some work
        }
    }
}

func main() {
    done := make(chan struct{})

    go worker(done)

    // Some condition to close worker
    close(done)
}
```
### Краткое содержание

**Thread Pool**: используется для ограничения количества одновременно выполняющихся задач, управляя числом горутин и предотвращая перегрузку системы. **Semaphore**: контролирует доступ к ограниченным ресурсам, ограничивая количество горутин, которые могут одновременно их использовать. **Fan-In**: объединяет результаты нескольких горутин в один канал. **Fan-Out**: распределяет задачи среди нескольких горутин для параллельной обработки. **Done Channel**: используется для безопасного завершения горутин, позволяя передать сигнал остановки. ^sum-conc-patterns
