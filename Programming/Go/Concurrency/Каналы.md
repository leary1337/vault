---
создал заметку: 2024-07-27
tags:
  - golang
  - concurrency
---
### Описание

Каналы — одна из ключевых особенностей языка Go, делающая его привлекательным для разработчиков. Вместе с горутинами, каналы позволяют писать правильный код, обеспечивая простой способ передачи данных между горутинами и управления их синхронизацией.
#### Свойства каналов

1. **Потокобезопасность**: Каналы обеспечивают безопасность потоков, позволяя одновременно работать нескольким горутинам без необходимости использования мьютексов или других примитивов синхронизации.
2. **Семантика FIFO (First In, First Out)**: Элементы в канале обрабатываются в порядке поступления.
3. **Передача данных**: Каналы предназначены для передачи данных между горутинами.
4. **Блокировка горутин**: Горутины могут быть временно заблокированы при попытке чтения из пустого канала или записи в заполненный.

#### Внутренняя структура каналов

Каналы реализуются с использованием структуры, хранящейся в куче (heap).
```go
type hchan struct {  
    qcount   uint           // total data in the queue  
    dataqsiz uint           // size of the circular queue  
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16  
    closed   uint32  
    elemtype *_type // element type  
    sendx    uint   // send index
    recvx    uint   // receive index  
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters
    
    // lock protects all fields in hchan, as well as several  
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G's status while holding this lock  
    // (in particular, do not ready a G), as this can deadlock  
    // with stack shrinking.
    lock mutex  
}

type waitq struct {  
    first *sudog  
    last  *sudog  
}

type sudog struct {  
    g *g  
    next *sudog  
    prev *sudog  
    elem unsafe.Pointer // data element (may point to stack)
	c *hchan // channel  
}
```
Основные компоненты структуры канала:

- **qcount**: Текущее количество элементов в буфере.
- **dataqsiz**: Размер буфера.
- **buf**: Ссылка на область памяти, где хранятся элементы. Представляет собой кольцевую очередь.
- **sendx** и **recvx**: Номера ячеек буфера из которых будет производится чтение и запись данных.
- **closed**: Флаг, указывающий на состояние канала (закрыт/не закрыт). Тип `uint32`, потому что данный параметр будет меняться через `atomic`, а он не умеет работать с `bool`.
- **recvq** и **sendq**: Очереди горутин, ожидающих чтения или записи в канал.
- **lock**: Мьютекс для синхронизации доступа к каналу.

Структура `waitq` представляет собой очередь горутин, ожидающих операций на канале, и состоит из двух указателей:

- `first`: Указатель на первый элемент очереди (голову).
- `last`: Указатель на последний элемент очереди (хвост).

Эти структуры используются для управления горутинами, ожидающими записи в канал (`sendq`) или чтения из канала (`recvq`).

Структура `sudog` представляет собой элемент очереди ожидания и хранит информацию о горутине, ожидающей операции на канале. Каждый элемент `sudog` содержит:

- Ссылку на горутину (`g`).
- Ссылку на канал (`c`).
- Указатель на следующую и предыдущую записи в очереди (`next` и `prev`).
- Ссылку на данные, которые должны быть записаны или прочитаны (`elem`).

#### Работа с каналами

**Создание канала:**

При создании канала в Go необходимо использовать функцию `make`, чтобы инициализировать структуру канала. Если попытаться использовать канал без инициализации, это приведет к *deadlock*, так как операции над `nil` каналом невозможны.

Пример ошибки:
```go
var ch chan int
ch <- 1   // fatal error: all goroutines are asleep - deadlock!
<-ch      // fatal error: all goroutines are asleep - deadlock!
close(ch) // panic: close of nil channel
```

![](https://i.imgur.com/AbcNBVq.png)


**Запись в канал:**

![](https://i.imgur.com/0td6YfY.png)

1. **Блокировка мьютекса**:
    - Для обеспечения потокобезопасности канал блокируется мьютексом.

2. **Проверка закрытия канала**:
    - Проверяется, не закрыт ли канал. Если канал закрыт, *операция записи вызывает панику.*

3. **Проверка наличия ожидающих горутин в `recvq`**:
    - Если в очереди `recvq` есть горутины, ожидающие чтения, одна из них немедленно получает данные. В этом случае:
        - Из очереди `recvq` извлекается элемент `sudog`, соответствующий горутине, ожидающей чтения.
        - Данные передаются непосредственно этой горутине с использованием `elem` из `sudog`.
        - Горутина из `sudog` разблокируется и удаляется из очереди `recvq`.

4. **Запись в буфер (для буферизованных каналов)**:
    - Если канал буферизованный и в буфере есть свободное место, данные **копируются** в буфер. Индекс записи (`sendx`) увеличивается. Если буфер заполнен, горутина, пытающаяся записать данные, блокируется:
        - Создается новый элемент `sudog` с текущей горутиной и данными для записи (`elem`).
        - Этот `sudog` добавляется в очередь `sendq` с использованием структуры `waitq`.
        - Горутина блокируется до тех пор, пока не станет возможна запись.

5. **Обновление состояния и разблокировка мьютекса**:
    - После завершения операции данные копируются в буфер или передаются ожидающей горутине.
    - Мьютекс разблокируется.

6. **Пробуждение горутин**:
    - Если в буфере освободилось место, горутины из очереди `recvq` пробуждаются для получения данных.

**Чтение из канала:**

![](https://i.imgur.com/N7tYxtU.png)

1. **Блокировка мьютекса**:
    - Как и в случае записи, чтение из канала начинается с блокировки мьютекса для обеспечения потокобезопасности.

2. **Проверка закрытия канала**:
    - Если канал закрыт и буфер пуст, возвращается "нулевое" значение типа, хранящегося в канале, и операция завершается.

3. **Проверка наличия данных в буфере**:
    - Если канал буферизованный и в буфере есть данные, они извлекаются из буфера, и индекс чтения (`recvx`) увеличивается. Данные **копируются** в переменную, куда горутина ожидала получить результат.

4. **Проверка наличия ожидающих горутин в `sendq`**:
    - Если в очереди `sendq` есть горутины, ожидающие записи, одна из них немедленно записывает данные в буфер. Это освобождает место в буфере, если буфер был полон, и горутина из `sendq` пробуждается.

5. **Обработка случая пустого канала**:
    - Если канал пуст и нет ожидающих горутин в `sendq`, горутина блокируется и добавляется в очередь `recvq`:
        - Создается новый элемент `sudog` с текущей горутиной.
        - Этот `sudog` добавляется в очередь `recvq`.
        - Горутина блокируется до тех пор, пока не появится данные для чтения.

6. **Разблокировка мьютекса**:
    - После завершения операции мьютекс разблокируется.

**Закрытие канала:**

Это операция, которая делает канал недоступным для последующих записей, но позволяет горутинам продолжать чтение данных, пока они не будут полностью изъяты. После закрытия канала попытки записи в него вызывают панику, а горутины, ожидающие данных, получают "нулевые" значения.

1. **Блокировка мьютекса**:
    - Для начала операции закрытия мьютекс канала блокируется, чтобы предотвратить одновременные изменения состояния канала другими горутинами.

2. **Проверка состояния канала**:
    - Проверяется, не закрыт ли уже канал. Если канал уже закрыт, операция вызывает панику, так как повторное закрытие канала запрещено.

3. **Установка флага `closed`**:
    - Флаг `closed` устанавливается в `true`, обозначая, что канал закрыт для дальнейших записей.

4. **Оповещение горутин в очереди `recvq`**:
    - Все горутины в очереди `recvq`, ожидающие чтения, извлекаются из очереди и оповещаются. Эти горутины могут продолжить выполнение, получив "нулевое" значение типа, который хранился в канале. Это позволяет им завершить свои операции чтения.

5. **Оповещение горутин в очереди `sendq`**:
    - Все горутины в очереди `sendq`, ожидающие записи, также извлекаются из очереди. Поскольку запись в закрытый канал запрещена, эти горутины вызывают панику.

6. **Разблокировка мьютекса**:
    - После завершения всех операций мьютекс разблокируется, позволяя другим горутинам выполнять операции с каналом (например, попытки чтения данных).

| **Операция**                | **Состояние канала**  | **Паника** | **Примечание**                                                         |
| --------------------------- | --------------------- | ---------- | ---------------------------------------------------------------------- |
| Чтение из канала (`<-chan`) | Открыт ✅              | Нет        | Чтение данных из канала.                                               |
| Чтение из канала (`<-chan`) | Закрыт ❌, данные есть | Нет        | Чтение оставшихся данных в буфере.                                     |
| Чтение из канала (`<-chan`) | Закрыт ❌, буфер пуст  | Нет        | Чтение "нулевого" значения типа канала.                                |
| Запись в канал (`chan<-`)   | Открыт ✅              | Нет        | Запись данных в канал.                                                 |
| Запись в канал (`chan<-`)   | Закрыт ❌              | Да         | Попытка записи вызывает панику (`panic: send on closed channel`).      |
| Закрытие канала (`close()`) | Открыт ✅              | Нет        | Канал успешно закрывается.                                             |
| Закрытие канала (`close()`) | Закрыт ❌              | Да         | Повторное закрытие вызывает панику (`panic: close of closed channel`). |
#### Конструкция `select`

Конструкция `select` в Go используется для управления конкурентными операциями с каналами, позволяя горутине ожидать выполнения операций на нескольких каналах. `select` блокируется до тех пор, пока не станет доступной одна из операций.

Основные аспекты конструкции `select`:

- **Множественные каналы**: Позволяет обрабатывать несколько каналов одновременно.
- **Неблокирующие операции**: Использование оператора `default` для выполнения кода, если ни один из каналов не готов.
- **Случайный выбор**: Если несколько каналов готовы, `select` случайным образом выбирает один из них.

Пример использования:
```go
select {
case msg := <-ch1:
    fmt.Println("Received", msg)
case ch2 <- 42:
    fmt.Println("Sent 42")
default:
    fmt.Println("No communication")
}
```
#### Виды чтения из канала

1. **Блокирующее чтение**:
	- Обычное чтение блокирует горутину, пока данные не станут доступны.
```go
value := <-ch
```

2. **Неблокирующее чтение**:
	- С использованием `select` с оператором `default` для избежания блокировки.
```go
select {
case value := <-ch:
    fmt.Println("Received", value)
default:
    fmt.Println("No data received")
}
```

3. **Чтение с проверкой закрытия канала**:
	- Чтение с использованием второго возвращаемого значения для проверки, был ли канал закрыт.
```go
value, ok := <-ch
if !ok {
    fmt.Println("Channel closed")
}
```

4. **Чтение в цикле**:
	- Если канал закрыт и в нем остались невычитанные данные, цикл `for range` продолжит читать данные до тех пор, пока не будут вычитаны все элементы из буфера канала.
```go
for value := range ch {
    fmt.Println("Received:", value)
}
```
#### Deadlocks и ошибки при работе с каналами

**Deadlock** (взаимная блокировка) — это состояние, при котором две или более горутины навсегда заблокированы, ожидая друг друга. В Go deadlock может возникнуть при неправильном использовании каналов и синхронизации.

**1. Ожидание на незаполненный канал:**

**Проблема**: Горутина ожидает данных из канала, но данные никогда не приходят.

```go
package main

func main() {
	ch := make(chan int)
	value := <-ch // Deadlock: ожидание данных из канала, но никто не пишет
	fmt.Println(value)
}
```

**Объяснение**: В этом примере основная горутина блокируется, ожидая данные из канала `ch`. Поскольку нет других горутин, записывающих данные в этот канал, программа блокируется навсегда.

**2. Запись в закрытый канал:**

**Проблема**: Попытка записи в закрытый канал вызывает панику.

```go
package main

func main() {
    ch := make(chan int)
    close(ch)
    ch <- 1 // Panic: запись в закрытый канал
}
```

**Объяснение**: После закрытия канала `close(ch)`, попытка записать в него данные вызывает панику. Это связано с тем, что в закрытый канал больше нельзя отправлять данные.

**3. Несинхронизированные горутины:**

**Проблема**: Одна горутина блокируется на чтении или записи, ожидая другой горутины, которая не будет выполняться.

```go
package main

func main() {
    ch := make(chan int)

    go func() {
        ch <- 1 // Горутине негде прочитать данные, возможен deadlock
    }()

    // Не ожидаем завершения горутины
}
```

**Объяснение**: В этом примере горутина, отправляющая данные в канал, блокируется, ожидая, пока другая горутина прочитает эти данные. Поскольку в основной функции нет соответствующего чтения, горутина блокируется, вызывая deadlock.

**4. Небуферизованный канал и отсутствие синхронизации:**

**Проблема**: Небуферизованный канал требует синхронизации между горутинами для успешного завершения операций передачи данных.

```go
package main

func main() {
    ch := make(chan int)

    go func() {
        ch <- 1 // Deadlock, если не будет чтения из канала
    }()

    // Отсутствие синхронизации, программа может завершиться раньше чтения данных
}
```

**Объяснение**: Небуферизованный канал блокируется до тех пор, пока не будут выполнены обе операции — чтение и запись. Если не синхронизировать горутины, может возникнуть ситуация, когда горутина пытается записать данные, но никто их не читает, что приводит к deadlock'у.

**5. Неочищенный буферизованный канал:**

**Проблема**: Буферизованный канал может заполняться, если его буфер не очищается достаточно быстро, что приводит к блокировке записывающей горутины.

```go
package main

func main() {
    ch := make(chan int, 1) // Буфер на 1 элемент

    ch <- 1 // Успешная запись
    ch <- 2 // Deadlock: буфер заполнен, нет чтения
}
```

**Объяснение**: В этом случае канал имеет буфер размером 1. Первая запись проходит успешно, но вторая блокируется, так как буфер заполнен и никто не читает данные.
#### Предотвращение Deadlock'ов

1. **Правильное использование `select`**:
    - `select` позволяет избежать блокировки, предоставляя альтернативный вариант выполнения, например, через `default`.

2. **Использование буферизованных каналов**:
    - Увеличение размера буфера канала может помочь избежать блокировок, связанных с ожиданием освобождения места для записи данных.

3. **Планирование синхронизации**:
    - Тщательное проектирование и синхронизация горутин, чтобы каждая операция записи сопровождалась операцией чтения, и наоборот.

4. **Использование `close()` для завершения работы с каналом**:
    - Закрытие канала и корректная обработка этого события помогают избежать зависания горутин в ожидании данных.

5. **Отладка и проверка кода**:
    - Регулярное тестирование и отладка помогают выявить потенциальные проблемы с синхронизацией и предотвратить deadlock'и.
### Краткое содержание

**Каналы** в Go — это мощный инструмент, упрощающий написание многопоточных программ. Они предоставляют удобные примитивы для синхронизации и обмена данными между горутинами, и их внутреннее устройство продумано для достижения баланса между производительностью и простотой использования. ^sum-channels
