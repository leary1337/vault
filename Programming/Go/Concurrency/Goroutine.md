---
создал заметку: 2024-07-27
tags:
  - golang
  - concurrency
---
### Описание
**Горутины (Goroutines)** — это легковесные потоки выполнения, которые [Go runtime](../Внутреннее%20устройство%20Go/Runtime.md) использует для параллельного выполнения задач. Они представляют собой продвинутую концепцию потоков, позволяющую работать с [многозадачностью и параллелизмом в Go](Основы%20конкурентности%20в%20Go.md). В отличие от традиционных потоков операционной системы (OS), горутины значительно легче и эффективнее в управлении.
#### Определение горутины

**Горутина** — это функция или метод, который выполняется параллельно с другими горутинами в той же программе. Запуск горутины осуществляется с помощью ключевого слова `go`, что позволяет программе асинхронно выполнять код без блокировки основного потока.

Пример запуска горутины:
```go
go func() {
    fmt.Println("Hello from goroutine!")
}()
```
В этом примере горутина выполняет анонимную функцию, печатающую сообщение в консоль. Основной поток программы продолжает своё выполнение параллельно с этой горутиной.
#### Отличия горутин от потоков ОС

1. **Управление и планирование**:
	Горутины управляются не операционной системой, а [Go runtime](../Внутреннее%20устройство%20Go/Runtime.md). Это означает, что Go runtime включает свой собственный **планировщик**, который распределяет выполнение горутин между доступными процессорными ядрами. В отличие от потоков ОС, которые требуют взаимодействия с ядром системы для управления и переключения контекста, *горутины управляются в пространстве пользователя*, что значительно снижает накладные расходы.

2. **Размер стека**:
	Горутины начинаются с минимального стека размером **2-4 КБ**, который может динамически расширяться по мере необходимости. В противоположность этому, потоки ОС обычно имеют фиксированный стек размером несколько мегабайт, что увеличивает потребление памяти.

3. **Изолированность от ОС**:
	Горутины не зависят от особенностей базовой операционной системы. Они работают в виртуальном пространстве Go runtime, что делает их переносимыми и независимыми от платформы. Это также упрощает реализацию оптимизаций, так как *они контролируются Go runtime, а не ОС*.

4. **Масштабируемость и производительность**:
	Горутины могут быть созданы в гораздо большем количестве, чем потоки ОС, без значительного влияния на производительность. Go runtime оптимизирует использование ресурсов и минимизирует накладные расходы на создание и переключение горутин.

#### Почему горутины легковесны?

Легковесность горутин обусловлена несколькими ключевыми факторами:
1. **Минимальный начальный размер стека**:
	Начальный стек горутины составляет всего 2-4 КБ, что значительно меньше, чем у потоков ОС. Это позволяет создавать тысячи горутин без значительного увеличения потребления памяти. При необходимости, если горутине требуется больше памяти, её стек может динамически расширяться.

2. **Динамическое управление стеком**:
	В отличие от потоков ОС, которые имеют фиксированный размер стека, горутины могут динамически изменять размер своего стека. Это позволяет эффективно использовать память и избегать избыточного резервирования ресурсов.

3. **Упрощённое переключение контекста**:
	Поскольку горутины управляются Go runtime, переключение контекста между ними выполняется на уровне пользователя, без вовлечения ядра операционной системы. Это значительно снижает накладные расходы на переключение контекста и повышает общую производительность.

4. **Низкая задержка и быстрое время запуска**:
	Горутины запускаются почти мгновенно и с минимальными затратами, что делает их идеальными для задач, требующих параллелизма и быстрой реакции на события.

#### Структура горутины

Основная структура данных, описывающая горутину, называется **g** (сокращение от “goroutine”). Основные поля и их описание:

1. **stack**:
	- Это стек горутины, который используется для хранения локальных переменных, параметров функций и другой контекстной информации. *Стек может динамически увеличиваться и уменьшаться по мере выполнения горутины*.

1. **sched**:
	- Содержит состояние выполнения горутины, такое как указатель на текущую инструкцию (PC — program counter), регистры и информация о вызовах функций. Это поле используется для сохранения контекста при переключении между горутинами.

3. **atomicstatus**:
	 - Это текущее состояние горутины, которое может включать такие значения, как *runnable (готова к выполнению)*, *running (выполняется)*, *waiting (ожидание)* и *dead (завершена)*. Это поле помогает Go-рутайму управлять жизненным циклом горутины.

4. **m**:
	- Указатель на структуру m, представляющую поток операционной системы (OS thread), который в данный момент выполняет эту горутину. Это поле позволяет горутине знать, на каком ОС потоке она выполняется.

5. **_defer**:
	- Список функций, которые должны быть выполнены при выходе из функции, в которой они были вызваны. Это полезно для очистки ресурсов и управления завершением горутины.

6. **_panic**:
	- Указатель на структуру, содержащую информацию о состоянии паники в случае, если горутина столкнулась с неразрешимой ошибкой. Это поле используется для обработки паник и восстановления после них.

### Краткое содержание

**Горутины (Goroutines)** — это легковесные потоки выполнения, которые [Go runtime](../Внутреннее%20устройство%20Go/Runtime.md) использует для параллельного выполнения задач. Они представляют собой продвинутую концепцию потоков, позволяющую работать с [многозадачностью и параллелизмом в Go](Основы%20конкурентности%20в%20Go.md). В отличие от традиционных потоков операционной системы (OS), горутины значительно легче и эффективнее в управлении. ^bacf49
