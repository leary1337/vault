---
создал заметку: 2024-07-24
tags:
  - network
  - protocols
  - "#security"
  - "#encryption"
  - "#applicationlayer"
---
### Описание

**SSL (Secure Sockets Layer)** и **TLS (Transport Level Security)** — криптографические протоколы, обеспечивающие защищенную передачу данных в компьютерной сети. Они широко используются в веб-браузерах, а также при работе с электронной почтой, обмене мгновенными сообщениями и в IP-телефонии.

Соединение, защищенное протоколом TLS, обладает одним или несколькими следующими свойствами:

- _Безопасность_: симметричное шифрование защищает передаваемую информацию от прочтения посторонними лицами.
- _Аутентификация_: "личность" участника соединения можно проверить с помощью асимметричного шифрования.
- _Целостность_: каждое сообщение содержит код (**Message Authentication Code, MAC**), с помощью которого можно проверить, что данные не были изменены или потеряны в процессе передачи.

Так как большинство протоколов связи могут быть использованы как с TLS/SSL, так и без него, при установке соединения необходимо явно указать серверу, хочет ли клиент устанавливать TLS. Один способ добиться этого — использовать порт, по которому соединение всегда устанавливается с использованием TLS (например, 443 для [HTTPS](HTTPS.md)). Другой способ — использовать специальную команду серверу от клиента переключить соединение на TLS (например, STARTTLS для протоколов электронной почты).
#### История и Развитие

SSL был разработан компанией Netscape для безопасного соединения в Интернете. Впоследствии, из-за уязвимостей SSL 2.0, была разработана версия SSL 3.0. *TLS 1.0*, известный также как SSL 3.1, *стал стандартом*, заменив SSL 3.0, с улучшениями в безопасности.

#### Принцип работы TLS

Протокол TLS делится на два слоя: **TLS Record** и **TLS Handshake**.

**Подтверждение связи (handshake)**
![Pasted image 20240727151423](Pasted%20image%2020240727151423.png)
1. Клиент посылает сообщение **ClientHello**, указывающее версию SSL или TLS и поддерживаемые клиентом методы шифрования (англ. _CipherSuite_). Это сообщение также содержит случайное число (набор байт), которое используется в последующих вычислениях. Протокол также позволяет указать поддерживаемые клиентом методы сжатия данных.
2. Сервер отвечает сообщением **ServerHello**, которое содержит метод шифрования, выбранный сервером из списка, предложенного клиентом, а также идентификатор сессии и еще одно случайное число. Также сервер посылает свой цифровой сертификат. Если серверу нужен сертификат для аутентификации клиента, на этом шаге он может послать клиенту запрос такого сертификата.
3. Клиент проверяет сертификат сервера.
4. Клиент отправляет случайное число, которое клиент и сервер используют для шифрования последующих сообщений. Сама строка из байт шифруется публичным ключом сервера.
5. Если сервер потребовал у клиента сертификат, клиент отсылает набор байт, зашифрованный его секретным ключом, и свой цифровой сертификат, или оповещение об отсутствии сертификата.
6. Сервер проверяет сертификат клиента.
7. Клиент и сервер отправляют друг другу сообщение **ChangeCipherSpec**, объявляя об изменении режима передачи данных с незащищенного на защищенный.
8. Клиент отправляет сообщение **Finished**, зашифрованное секретным ключом, и таким образом завершает подтверждение связи со своей стороны.
9. Аналогичные действия производит сервер.
10. На протяжении данной сессии клиент и сервер могут обмениваться сообщениями, зашифрованными секретным ключом.

**Возобновление сессии**

1. Клиент посылает сообщение **ClientHello**, используя ID сессии, которую нужно возобновить.
2. Сервер проверяет, есть ли у него в кэше соответствующий идентификатор. Если есть и сервер способен возобновить сессию, он отсылает клиенту сообщение **ServerHello** с этим же ID сессии. Если нет, сервер генерирует новый ID сессии и выполняет процедуру handshake с клиентом.
3. Клиент и сервер обмениваются сообщениями **ChangeCipherSpec**, а затем **Finished**.
4. Передача данных по защищенному каналу возобновляется.

**Протокол записи (TLS Record)**

Этот слой защищает данные с помощью ключей, полученных при подтверждении связи, и проверяет целостность и источник входящих сообщений. Он выполняет следующие функции:

- Разбиение исходящих сообщений на блоки нужного размера и "склеивание" входящих сообщений.
- Сжатие исходящих сообщений и распаковку входящих (используется не всегда).
- Применение кода аутентификации к исходящим сообщениям и проверку входящих с помощью MAC.
- Шифрование исходящих сообщений и дешифровку входящих.

После обработки протоколом TLS Record зашифрованные данные передаются на слой TCP для передачи.

#### Состав записи

[![Схема записи](https://neerc.ifmo.ru/wiki/images/3/3d/TLS-Record.png)](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:TLS-Record.png "Схема записи")

- _Content type_: тип сообщения — подтверждение связи (22), обычное сообщение (23) или оповещение (21).
- _Version_: версия SSL/TLS.
- _Length_: длина оставшейся части сообщения.
- _Payload_: собственно зашифрованные данные.
- _MAC_: код аутентификации.
- _Padding_: "отступ" для получения нужного размера сообщения.
#### Цифровые сертификаты (стандарт X.509)

- Удобный способ показать, что кто-то владеет публичным ключом.
- Выпускаются центрами сертификации (**Certificate Authority, CA**): GlobalSign, Comodo и др.
- PKI (public key infrastructure) — механизм, регулирующий распространение и использование сертификатов (включая создание, отзыв и проверку подлинности).
- Список доверенных CA поддерживается приложением (у браузеров свои списки).
- Сертификаты подписываются другими сертификатами, что повышает надежность.
- Сертификат может быть отозван. Система поддерживает список таких сертификатов (**Certificate Revocation List, CRL**). На стороне CA список обновляется каждые несколько часов.

**Получение сертификата**

1. Пользователь генерирует ключ и посылает запрос серверу CA.
2. CA отвечает сообщением со своим сертификатом.
3. Пользователь собирает данные, необходимые для выдачи сертификата (email, отпечаток ключа и т.д.).
4. Пользователь отправляет данные в CA, зашифровав их публичным ключом CA.
5. CA проверяет полученные данные и отправляет сертификат пользователю.

**Структура сертификата**
  
![Структура X.509](https://neerc.ifmo.ru/wiki/images/c/c2/Cert-structure.png)
- Собственно сертификат
    - Версия
    - Серийный номер
    - Эмитент (тот, кто выпустил сертификат)
    - Субъект
    - Публичный ключ субъекта
    - Период действия
    - Дополнительные поля
- Алгоритм подписи сертификата
- Значение подписи сертификата
#### Меры безопасности в TLS

- Защита от downgrade-атаки — понижения версии протокола к предыдущей (менее защищённой) версии или менее надёжному алгоритму шифрования;
- Нумерация последовательных записей приложения и использование порядкового номера в коде аутентификации сообщения (MAC);
- Использование ключа в идентификаторе сообщения (только владелец ключа может сгенерировать код аутентификации сообщения).
- Сообщение, которым заканчивается подтверждение связи («Finished»), содержит хэш всех handshake-сообщений, отправленных обеими сторонами, что позволяет проверить подлинность выбранных параметров TLS-соединения.
- Псевдослучайная функция делит подаваемые ей на вход данные пополам, применяет к половинкам разные хэш-алгоритмы (MD5 и SHA-1), а затем XOR'ит результаты для получения MAC. Это повышает безопасность в случае, если в одном из алгоритмов обнаружится уязвимость.

#### Ключевые отличия SSL и TLS

- _Аутентификация сообщений_: в TLS используется HMAC, работающий с любой хэш-функцией (а не только с MD5 или SHA, как в SSL).
- _Генерация ключа_: в TLS при создании ключа используется псевдослучайная функция стандарта HMAC; в SSL — RSA, Diffie-Hellman или Fortezza/DMS.
- _Проверка сертификата_: в SSL проверка требует передачи сложной последовательности сообщений; в TLS информация о проверке полностью передается в сообщениях во время handshake.
- _Методы шифрования_: SSL поддерживает только алгоритмы RSA, Diffie-Hellman и Fortezza/DMS. В TLS отказались от поддержки Fortezza/DMS, но возможно добавление новых методов шифрования в последующих версиях.
### Краткое содержание

**SSL и TLS** — это криптографические протоколы, обеспечивающие безопасную передачу данных через интернет с помощью шифрования и аутентификации. Они защищают данные от перехвата и модификации, используя симметричное и асимметричное шифрование, а также коды аутентификации сообщений (MAC). *TLS* является более современной и безопасной версией, заменившей *SSL*, и используется для защиты соединений в веб-браузерах, электронной почте и других интернет-приложениях. ^70096d
